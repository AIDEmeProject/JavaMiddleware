package machinelearning.active.learning.versionspace.convexbody.sampling;

import machinelearning.active.learning.versionspace.convexbody.ConvexBody;
import machinelearning.active.learning.versionspace.convexbody.Line;
import machinelearning.active.learning.versionspace.convexbody.LineSegment;
import machinelearning.active.learning.versionspace.convexbody.sampling.direction.DirectionSampler;
import utils.RandomState;
import utils.Validator;
import utils.linalg.Vector;

import java.util.Objects;
import java.util.Random;

/**
 * Hit-and-Run is an algorithm for sampling points uniformly at random from a bounded convex body K. It generates a
 * Markov chain of points in the interior of K which converges to the uniform distribution over K. Thi Markov Chain
 * is defined by:
 *
 *     1: \(X_0\) = any point inside the convex body
 *     2: for \(t\) from \(1\) to \(T\):
 *     3:    line = sample a random line going through \(X_t\)
 *     4:    segment = intersection between line and K
 *     5:    \(K_{t+1}\) = a random point in the segment
 *
 * REFERENCES:
 *      Hit-and-run mixes fast, Laszlo Lovasz
 */
public final class HitAndRun {
    /**
     * {@link ConvexBody} to sample from
     */
    private ConvexBody body;

    /**
     * {@link DirectionSampler} instance for sampling random directions
     */
    private DirectionSampler directionSampler;

    /**
     * Hit-and-Run chain starting point
     */
    private final Vector initialSample;

    /**
     * @throws NullPointerException if any of the input parameters are null
     */
    public HitAndRun(ConvexBody body, DirectionSampler directionSampler) {
        this.body = Objects.requireNonNull(body);
        this.directionSampler = Objects.requireNonNull(directionSampler);
        this.initialSample = body.getInteriorPoint();
    }

    /**
     * @return a new Hit-and-Run chain. All chains have their own, independent random state
     */
    public final Chain newChain() {
        return new Chain(initialSample);
    }

    /**
     * This class is responsible for generating the Hit-and-Run samples. Each Chain object is an independent run of
     * the Hit-and-Run algorithm.
     */
    public final class Chain {
        /**
         * Last sample generated by the Markov Chain
         */
        private Vector currentSample;

        /**
         * Random number generator
         */
        private final Random random;

        private Chain(Vector currentSample) {
            this.currentSample = currentSample;
            this.random = RandomState.newInstance();
        }

        /**
         * @return the next sample of this Markov Chain. It corresponds to the lines 3 to 5 in the pseudo-code above.
         */
        public Vector advance() {
            Line line = new Line(currentSample, directionSampler.sampleDirection(random));
            LineSegment segment = body.computeLineIntersection(line);
            currentSample = segment.getPoint(random.nextDouble());
            return currentSample;
        }

        /**
         * @param n: number of iterations to advance in the chain
         * @return the last sample
         */
        public Vector advance(int n) {
            Validator.assertPositive(n);

            for (int i = 0; i < n; i++) {
                currentSample = advance();
            }
            return currentSample;
        }

    }
}
