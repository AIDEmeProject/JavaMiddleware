package machinelearning.active.learning.versionspace.convexbody.sampling;

import machinelearning.active.learning.versionspace.convexbody.ConvexBody;
import machinelearning.active.learning.versionspace.convexbody.Line;
import machinelearning.active.learning.versionspace.convexbody.LineSegment;
import machinelearning.active.learning.versionspace.convexbody.sampling.direction.DirectionSampler;
import utils.Validator;

import java.util.Objects;
import java.util.Random;

/**
 * Hit-and-Run is an algorithm for sampling points uniformly at random from a bounded convex body K. It generates a
 * Markov chain of points in the interior of K which converges to the uniform distribution over K. Thi Markov Chain
 * is defined by:
 *
 *     1: \(X_0\) = any point inside the convex body
 *     2: for \(t\) from \(1\) to \(T\):
 *     3:    line = sample a random line going through \(X_t\)
 *     4:    segment = intersection between line and K
 *     5:    \(K_{t+1}\) = a random point in the segment
 *
 * REFERENCES:
 *      Hit-and-run mixes fast, Laszlo Lovasz
 */
public class HitAndRunChain {
    /**
     * {@link ConvexBody} to sample from
     */
    private ConvexBody body;

    /**
     * {@link DirectionSampler} instance for sampling random directions
     */
    private DirectionSampler directionSampler;

    /**
     * Random number generator
     */
    private final Random rand;

    /**
     * Last sample generated by the Markov Chain
     */
    private double[] currentSample;

    /**
     * Initialize the MarkovChain with the body.getInteriorPoint() method.
     */
    HitAndRunChain(ConvexBody body, DirectionSampler directionSampler, Random rand) {
        this(body, directionSampler, rand, body.getInteriorPoint());
    }

    private HitAndRunChain(ConvexBody body, DirectionSampler directionSampler, Random rand, double[] currentSample) {
        this.body = Objects.requireNonNull(body);
        this.directionSampler = Objects.requireNonNull(directionSampler);
        this.rand = Objects.requireNonNull(rand);
        this.currentSample = currentSample;
    }

    /**
     * @return the next sample of this Markov Chain. It corresponds to the lines 3 to 5 in the pseudo-code above.
     */
    public double[] advance() {
        Line line = new Line(currentSample, directionSampler.sampleDirection(rand));
        LineSegment segment = body.computeLineIntersection(line);
        currentSample = segment.getPoint(rand.nextDouble());
        return currentSample;
    }

    /**
     * @param n: number of iterations to advance in the chain
     * @return the last sample
     */
     public double[] advance(int n) {
        Validator.assertPositive(n);

        for (int i = 0; i < n; i++) {
            currentSample = advance();
        }
        return currentSample;
    }

    /**
     * @return an independent copy of this Markov Chain, at the same current point. Both objects will share the same
     * random state though TODO: can we avoid this?
     */
     public HitAndRunChain copy() {
        return new HitAndRunChain(body, directionSampler, rand, currentSample.clone());
    }
}
